---
title: "Data Structures and Algorithms - Introduction"
excerpt_separator: "<!--more-->"
categories:
 - Data Structures and Algorithms 
tags:
 - DSA
---

Curated list of data structures and algorithms that are particularly useful in game development

<!--more-->

## Data Structures

1. **Arrays and Vectors**
    - Basic storage, used for dynamic lists of elements
    - Example: Player inventories, level data.

2. **Linked Lists**
    - Useful for dynamic memory management.
    - Example: Undo functionality, game state history.

3. **Stacks and Queues**
    - Stacks: Used for depth-first search (DFS), backtracking.
    - Queues: Used for breadth-first search (BFS), task scheduling.
    - Example: AI decision-making, game event handling.

4. **Hash Tables (Unordered Maps)**
    - Fast lookups, inserts, and deletes.
    - Example: Game asset management, fast access to game objects.

5. **Binary Search Trees (BST)**
    - Used for sorted data and range queries.
    - Example: Leaderboards, balancing game mechanics.

6. **Heaps (Priority Queues)**
    - Efficient priority management.
    - Example: AI pathfinding (A* algorithm), task scheduling.

7. **Graphs**
    - Represent networks of interconnected objects.
    - Example: Pathfinding, game maps, social graphs in multiplayer games.

8. **Spatial Data Structures**
    - Quadtrees and Octrees: Efficiently manage spatial information.
    - KD-Trees: Used for nearest neighbor searches.
    - BVH (Bounding Volume Hierarchy): Used for collision detection.


## Algorithms

1. **Sorting Algorithms**
    - Quick Sort, Merge Sort, Heap Sort: Efficient sorting techniques.
    - Radix Sort: Useful for integer sorting, often used in graphics processing.

2. **Search Algorithms**
    - Binary Search: Fast searching in sorted arrays.
    - Hash-based Search: Fast searching using hash tables.

3. **Graph Algorithms**
    - Dijkstraâ€™s Algorithm: Shortest path in weighted graphs.
    - A Search Algorithm:* Used extensively in pathfinding.
    - DFS and BFS: Fundamental for exploring nodes and paths.

4. **Dynamic Programming**
    - Solving problems by breaking them down into simpler subproblems.
    - Example: Optimal game strategies, resource allocation.

5. **Greedy Algorithms**
    - Making the locally optimal choice at each stage.
    - Example: AI decision-making, scheduling.

6. **Mathematical Algorithms**
    - Linear Algebra: Matrix operations for graphics, physics simulations.
    - Fast Inverse Square Root: Optimization for 3D graphics.

7. **Collision Detection Algorithms**
    - Separating Axis Theorem (SAT): Detecting collisions between convex shapes.
    - Sweep and Prune: Efficient broad-phase collision detection.
    - Ray Casting: Line-of-sight checks, visibility checks.

8. **Memory Management Techniques**
    - Pool Allocators: Efficient memory allocation for game objects.
    - Smart Pointers: Managing resource lifetimes.